<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en" data-bs-theme="auto"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><title>fundamentals of Natural Language Processing (NLP) in Python: Episode 4: BERT and Transformers</title><meta name="viewport" content="width=device-width, initial-scale=1"><script src="../assets/themetoggle.js"></script><link rel="stylesheet" type="text/css" href="../assets/styles.css"><script src="../assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="../favicons/incubator/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicons/incubator/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="../favicons/incubator/favicon-16x16.png"><link rel="manifest" href="../favicons/incubator/site.webmanifest"><link rel="mask-icon" href="../favicons/incubator/safari-pinned-tab.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="black"></head><body>
    <header id="top" class="navbar navbar-expand-md top-nav incubator"><svg xmlns="http://www.w3.org/2000/svg" class="d-none"><symbol id="check2" viewbox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></symbol><symbol id="circle-half" viewbox="0 0 16 16"><path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path></symbol><symbol id="moon-stars-fill" viewbox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path><path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></symbol><symbol id="sun-fill" viewbox="0 0 16 16"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></symbol></svg><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-8">
      <div class="large-logo">
        <img id="incubator-logo" alt="Carpentries Incubator" src="../assets/images/incubator-logo.svg"><span class="badge text-bg-danger">
          <abbr title="This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.">
            <a href="https://cdh.carpentries.org/the-lesson-life-cycle.html#early-development-pre-alpha-through-alpha" class="external-link alert-link">
              <i aria-hidden="true" class="icon" data-feather="alert-octagon" style="border-radius: 5px"></i>
              Pre-Alpha
            </a>
            <span class="visually-hidden">This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.</span>
          </abbr>
        </span>

      </div>
    </div>
    <div class="selector-container">
      <div id="theme-selector">
        <li class="nav-item dropdown" id="theme-button-list">
          <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
            <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text"><li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                Light
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                Dark
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                Auto
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
          </ul></li>
      </div>

      <div class="dropdown" id="instructor-dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1"><li><button class="dropdown-item" type="button" onclick="window.location.href='../02-transformers.html';">Learner View</button></li>
        </ul></div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle Navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="Carpentries Incubator" src="../assets/images/incubator-logo-sm.svg"></div>
    <div class="lesson-title-md">
      fundamentals of Natural Language Processing (NLP) in Python
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
        <i role="img" aria-label="Search the All In One page" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item">
          <span class="lesson-title">
            fundamentals of Natural Language Processing (NLP) in Python
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/instructor-notes.html">Instructor Notes</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/images.html">Extract All Images</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown"><hr></ul></li>
      </ul></div>
    <!--
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
      <input class="form-control me-2 searchbox" type="search" placeholder="" aria-label="">
        <button class="btn btn-outline-success tablet-search-button"  type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="Search the All In One page"></i>
        </button>
      </fieldset>
    </form>
    -->
    <a id="search-button" class="btn btn-primary" href="../instructor/aio.html" role="button" aria-label="Search the All In One page">Search the All In One page</a>
  </div><!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  fundamentals of Natural Language Processing (NLP) in Python
</div>

<aside class="col-md-12 lesson-progress"><div style="width: 97%" class="percentage">
    97%
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: 97%" aria-valuenow="97" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
<div id="sidebar-col" class="col-lg-4">
  <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle" data-collapse="Collapse " data-episodes="Episodes ">
          <i class="search-icon" data-feather="x" role="img"></i>
        </button>
        <div class="sidebar-inner">
          <div class="row mobile-row" id="theme-row-mobile">
            <div class="col" id="theme-selector">
              <li class="nav-item dropdown" id="theme-button-list">
                <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
                  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><span class="d-lg-none ms-1" id="bd-theme-text">Toggle Theme</span>
                </button>
                <ul class="dropdown-menu dropdown-menu-right" aria-labelledby="bd-theme-text"><li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                      Light
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                      Dark
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                      <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                      Auto
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                </ul></li>
            </div>
          </div>
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="../02-transformers.html">Learner View</a>
                      </div>
                    </div>
                  </div><!--/div.accordion-item-->
                </div><!--/div.accordion-flush-->
              </div><!--div.sidenav-view-selector -->
            </div><!--/div.col -->

            <hr></div><!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Schedule</a>
    </div><!--/div.accordion-header-->

  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="00-introduction.html">1. Introduction</a>
    </div><!--/div.accordion-header-->

  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush3">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading3">
        <a href="01-preprocessing.html">2. Episode 1: From text to vectors</a>
    </div><!--/div.accordion-header-->

  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlushcurrent">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-headingcurrent">
        <span class="visually-hidden">Current Chapter</span>
        <span class="current-chapter">
        3. Episode 4: BERT and Transformers
        </span>
      
    </div><!--/div.accordion-header-->

  </div><!--/div.accordion-item-->
</div><!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width"><div class="accordion accordion-flush lesson-resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="lesson-resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul><li>
                        <a href="../instructor/key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="../instructor/instructor-notes.html">Instructor Notes</a>
                      </li>
                      <li>
                        <a href="../instructor/images.html">Extract All Images</a>
                      </li>
                      <hr></ul></div>
                </div>
              </div>
            </div>
            <hr class="half-width lesson-resources"><a href="../instructor/aio.html">See all in one page</a>


            <hr class="d-none d-sm-block d-md-none"><div class="d-grid gap-1">

            </div>
          </div><!-- /div.accordion -->
        </div><!-- /div.sidebar-inner -->
      </nav></div><!-- /div.sidebar -->
  </div><!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-instructor.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <nav class="lesson-content mx-md-4" aria-label="Previous and Next Chapter"><!-- content for small screens --><div class="d-block d-sm-block d-md-none">
        <a class="chapter-link" href="../instructor/01-preprocessing.html"><i aria-hidden="true" class="small-arrow" data-feather="arrow-left"></i>Previous</a>
        <a class="chapter-link float-end" href="../instructor/index.html">Next<i aria-hidden="true" class="small-arrow" data-feather="arrow-right"></i></a>
      </div>
      <!-- content for large screens -->
      <div class="d-none d-sm-none d-md-block">
        <a class="chapter-link" href="../instructor/01-preprocessing.html" rel="prev">
          <i aria-hidden="true" class="small-arrow" data-feather="arrow-left"></i>
          Previous: Episode 1: From text
        </a>
        <a class="chapter-link float-end" href="../instructor/index.html" rel="next">
          Home
          <i aria-hidden="true" class="small-arrow" data-feather="arrow-right"></i>
        </a>
      </div>
      <hr></nav><main id="main-content" class="main-content"><div class="container lesson-content">
        <h1>Episode 4: BERT and Transformers</h1>
        <p>Last updated on 2024-12-20 |

        <a href="https://github.com/esciencecenter-digital-skills/Natural-language-processing/edit/main/episodes/02-transformers.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>



        <p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 10 minutes</p>

        <div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>

        

<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul><li>What are Transformers?</li>
<li>What is BERT and how does it work?</li>
<li>How can I use BERT as a text classifier?</li>
<li>How should I evaluate my classifiers?</li>
</ul></div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<p>After following this lesson, learners will be able to:</p>
<ul><li>Understand how a Transformer works and recognize their different use
cases.</li>
<li>Use pre-trained transformers language models (e.g. BERT) to classify
texts.</li>
<li>Use a pre-trained transformer Named Entity Recognizer.</li>
<li>Understand assumptions and basic evaluation for NLP outputs.</li>
</ul></div>
</div>
</div>
</div>
</div>
<p>In the previous lesson we learned how Word2Vec can be used to
represent words as vectors. Having these representations allows us to
apply operations directly on the vectors that have numerical properties
that can be mapped to some syntactic and semantic properties of words;
such as the cases of analogies or finding synonyms. Once we transform
words into vectors, these can also be used as <strong>features</strong>
for classifiers that can be trained predict any supervised NLP task.</p>
<p>The main drawback of Word2Vec is that each word is represented in
isolation, and unfortunately that is not how language works. Words get
their meanings based on the specific context in which they are used
(take for example polysemy, the cases where the same word can have very
different meanings depending on the context); therefore, we would like
to have richer vector representations of words that also integrate
context into account in order to obtain more powerful
representations.</p>
<p>In 2019, the BERT language model was introduced using a novel
architecture called Transformer (2017), which allowed precisely to
integrate words’ context into representations. To understand BERT, we
will first look at what a transformer is and we will then directly use
some code to make use of BERT.</p>
<div class="section level1">
<h1 id="transformers">Transformers<a class="anchor" aria-label="anchor" href="#transformers"></a></h1>
<p>Every text can be seen as a sequence of sentences and likewise each
sentence can be seen as a sequence of tokens (we use the term
<em>token</em> instead of <em>word</em> because it is more general:
tokens can be words, punctuation symbols, numbers, or even sub-words).
Traditionally Recurrent Neural Networks (RNNs; and later their fancy
version, LSTMs) were used to tackle token and sentence classification
problems to account for the interdependencies inherent to sequences of
symbols (i.e. sentences). RNNs were in theory powerful enough to capture
these dependencies, something that is very valuable when dealing with
language, but in practice they were resource consuming (both in training
time and computational resources) and also the longer the sequences got,
the harder it was to capture long-distance dependencies succesfully.</p>
<p>The Transformer is a neural network architecture proposed by Google
researchers <a href="https://arxiv.org/pdf/1706.03762" class="external-link">in 2017</a> to
address these and other limitations of RNNs and LSTMs. In their paper,
<em>Attention is all you Need</em>, they tackled specifically the
problem of Machine Translation (MT), which in NLP terms is stated as:
how to generate a sentence (sequence of words) in target language B
given a sentence in source language A? In order to translate, first one
neural network needs to <em>encode</em> the meaning of the source
language A into vector representations, and then a second neural network
needs to <em>decode</em> that representation into tokens that are
understandable in language B. Therefore translation is modeling language
B <em>conditioned</em> on what language A originally said.</p>
<figure><img src="../fig/trans1.png" alt="Transformer Architecture" class="figure mx-auto d-block"><div class="figcaption">Transformer Architecture</div>
</figure><p>As seen in the picture, the original Transformer is an
Encoder-Decoder network that tackles translation. We first need a token
embedder which converts the string of words into a sequence of vectors
that the Transformer network can process. The first component, the
<strong>Encoder</strong>, is optimized for creating rich representations
of the source sequence (in this case an English sentence) while the
second one, the <strong>Decoder</strong> is a generative network that is
conditioned on the encoded representation and, with the help of the
attention mechanism, generates the most likely token in the target
sequence (in this case Dutch words) based on both the tokens generated
so far and the full initial English context.</p>
<p>Next, we will see how BERT exploits the idea of a Transformer Encoder
to generate powerful word representations.</p>
</div>
<div class="section level1">
<h1 id="bert">BERT<a class="anchor" aria-label="anchor" href="#bert"></a></h1>
<p><a href="https://aclanthology.org/N19-1423.pdf" class="external-link">BERT</a> is an
acronym that stands for <strong>B</strong>idirectional
<strong>E</strong>ncoder <strong>R</strong>epresentations from
<strong>T</strong>ransformers. The name describes it all: the idea is to
use the power of the Encoder component of the Transformer architecture
to create powerful token representations that preserve the contextual
meaning of the whole input segment. The BERT vector representations of
each token take into account both the left context (what comes before
the word) and the right context (what comes after the word). Another
advantage of the transformer Encoder is that it is parallelizable, which
made it posible for the first time to train these networks on millions
of datapoints, dramatically improving model generalization.</p>
<div id="pretraining-bert" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="pretraining-bert" class="callout-inner">
<h3 class="callout-title">Pretraining BERT</h3>
<div class="callout-content">
<p>To obtain the BERT vector representations the Encoder is pre-trained
with two different tasks: - <strong>Masked Language Model:</strong> for
each sentence, mask one token at a time and predict which token is
missing based on the context from both sides. A training input example
would be “Maria [MASK] Groningen” and the model should predict the word
“loves”. - <strong>Next Sentence Prediction:</strong> the Encoder gets a
linear binary classifier on top, which is trained to decide for each
pair of sequences A and B, if sequence A precedes sequence B in a text.
For the sentence pair: “Maria loves Groningen.” and “This is a city in
the Netherlands.” the output of the classifier is “True” and for the
pair “Maria loves Groningen.” and “It was a tasty cake.” the output
should be “false” as there is no obvious continuation between the two
sentences.</p>
<p>Already the second pre-training task gives us an idea of the power of
BERT: after it has been pretrained on hundreds of thousands of texts,
one can plug-in a classifier on top and re-use the <em>linguistic</em>
knowledge previously acquired to fine-tune it for a specific task,
without needing to learn the weights of the whole network from scratch
all over again. In the next sections we will describe the components of
BERT and show how to use it. This model and hundreds of related
transformer-based pre-trained encoders can also be found on <a href="https://huggingface.co/google-bert/bert-base-cased" class="external-link">Hugging
Face</a>.</p>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="bert-architecture">BERT Architecture<a class="anchor" aria-label="anchor" href="#bert-architecture"></a></h1>
<p>Now that we used the BERT language model component we can dive into
the architecture of BERT to understand it better.</p>
<p>As in any basic NLP pipeline, the first step is to pre-process the
raw text so it is ready to be fed into the Transformer. Tokenization in
BERT does not happen at the word-level but rather splits texts into what
they call WordPieces (the reason for this decision is complex, but in
short, researchers found that splitting <em>human words</em> into
<em>subtokens</em> exploits better the character sub-sequences inside
words and helps the model converge faster). A word then sometimes is
decomposed into one or several (sub) tokens.</p>
<ol style="list-style-type: decimal"><li>
<strong>Tokenizer:</strong> splits text into tokens that the model
recognizes</li>
<li>
<strong>Embedder:</strong> converts each token into a fixed-sized
vector that represents it. These vectors are the actual input for the
Encoder.</li>
<li>
<strong>Encoder</strong> several neural layers that model the
token-level interactions of the input sequence to enhance meaning
representation. The output of the encoder is a set of
<strong>H</strong>idden layers, the vector representation of the
ingested sequence.</li>
<li>
<strong>Output Layer:</strong> the final encoder layer (which we
depict as a sequence <strong>H</strong>’s in the figure) contains
arguably the best token-level representations that encode syntactic and
semantic properties of each token, but this time each vector is already
contextualized with the specific sequence.</li>
<li>
<em>OPTIONAL</em> <strong>Classifier Layer:</strong> an additional
classifier can be connected on top of the BERT token vectors which are
used as features for performing a downstream task. This can be used to
classify at the text level, for example sentiment analysis of a
sentence, or at the token-level, for example Named Entity
Recognition.</li>
</ol><figure><img src="../fig/bert3.png" alt="BERT Architecture" class="figure mx-auto d-block"><div class="figcaption">BERT Architecture</div>
</figure><div class="section level2">
<h2 id="bert-code">BERT Code<a class="anchor" aria-label="anchor" href="#bert-code"></a></h2>
<p>Let’s see how these components can be manipulated with code. For this
we will be using the HugingFace’s <em>transformers</em> python library.
We can install it with:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">SH<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode sh" tabindex="0"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="ex">pip</span> install transformers</span></code></pre>
</div>
<p>The first two main components we need to initialize are the model and
tokenizer. The HuggingFace hub contains thousands of models based on a
Transformer architecture for dozens of tasks, data domains and also
hundreds of languages. Here we will explore the vanilla English BERT
which was how everything started. We can initialize this model with the
next lines:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> BertTokenizer, BertModel</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>tokenizer <span class="op">=</span> BertTokenizer.from_pretrained(<span class="st">'bert-base-cased'</span>)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>model <span class="op">=</span> BertModel.from_pretrained(<span class="st">"bert-base-cased"</span>)</span></code></pre>
</div>
</div>
<div class="section level2">
<h2 id="bert-tokenizer">BERT Tokenizer<a class="anchor" aria-label="anchor" href="#bert-tokenizer"></a></h2>
<p>We start with a string of text as written in any blog, book,
newspaper etcetera. The <code>tokenizer</code> object is responsible of
splitting the string into recognizable tokens for the model and
embedding the tokens into their vector representations</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"Maria loves Groningen"</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>encoded_input <span class="op">=</span> tokenizer(text, return_tensors<span class="op">=</span><span class="st">'pt'</span>)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="bu">print</span>(encoded_input)</span></code></pre>
</div>
<p>The print shows the <code>encoded_input</code> object returned by the
tokenizer, with its attributes and values. The <code>input_ids</code>
are the most important output for now, as these are the token IDs
recognized by BERT</p>
<pre><code>{
    'input_ids': tensor([[  101,  3406,  7871,   144,  3484, 15016,   102]]),
    'token_type_ids': tensor([[0, 0, 0, 0, 0, 0, 0]]),
    'attention_mask': tensor([[1, 1, 1, 1, 1, 1, 1]])
}
</code></pre>
<p>NOTE: the printing function shows transformers objects as
dictionaries; however, to access the attributes, you must use the python
object syntax, such as in the following example:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="bu">print</span>(encoded_input.input_ids.shape)</span></code></pre>
</div>
<p>Output:</p>
<p><code>torch.Size([1, 7])</code></p>
<p>The output is a 2-dimensional tensor where the first dimention
contains 1 element (this dimension represents the batch size), and the
second dimension contains 7 elements which are equivalent to the 7
tokens that BERT generated with our string input.</p>
<div id="callout2" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>You noticed in the previous outputs the <code>tensor()</code> and
<code>torch()</code> wrappers around the arrays of integers. This is
showing that the <code>transformers</code> library uses
<code>pytorch</code> underneath, one of the most popular libraries for
Deep Learning in Python. Pytorch’s basic unit is the Tensor.</p>
<p>A <em>tensor</em> is a generalization of a multidimentional array of
data. By convention, a vector is a 1-dimensional sequence of scalar
numbers (or a 1-dim tensor), a matrix is a 2-dimensional sequence (2-dim
tensor) and for N-dimensions where N &gt; 2 we use the concept of
tensor.</p>
</div>
</div>
</div>
<p>In order to see what these Token IDs represent, we can
<em>translate</em> them into human readable strings. This includes
converting the tensors into numpy arrays and converting each ID into its
string representation:</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>token_ids <span class="op">=</span> <span class="bu">list</span>(encoded_input.input_ids[<span class="dv">0</span>].detach().numpy())</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>string_tokens <span class="op">=</span> tokenizer.convert_ids_to_tokens(token_ids)</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"IDs:"</span>, token_ids)</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"TOKENS:"</span>, string_tokens)</span></code></pre>
</div>
<p><code>IDs: [101, 3406, 7871, 144, 3484, 15016, 102]</code></p>
<p><code>TOKENS: ['[CLS]', 'Maria', 'loves', 'G', '##ron', '##ingen', '[SEP]']</code></p>
<p>These show us the WordPieces that the BERT Encoder will receive and
process. We will look more in detail into the tokenization and special
tokens later. For now, you just need to know that the encoder uses this
token IDs to retrieve the corresponding embedding vector from its
vocabulary, the string representations are just for the human
reader.</p>
</div>
<div class="section level2">
<h2 id="bert-output-object">BERT Output Object<a class="anchor" aria-label="anchor" href="#bert-output-object"></a></h2>
<p>To give a forward pass of the Encoder and obtain the vector
representations, we pass the <code>encoded_input</code> object generated
by the tokenizer.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>output <span class="op">=</span> model(<span class="op">**</span>encoded_input)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="bu">print</span>(output)</span></code></pre>
</div>
<p>The <code>output</code> variable in this case stores an ModelOutput
object, which contains a handful of values:</p>
<pre><code>BaseModelOutputWithPoolingAndCrossAttentions(
    last_hidden_state=tensor([[
        [6.3959e-02, -4.8466e-03, -8.4682e-02,  ..., -2.8042e-02, 4.3824e-01,  2.0693e-02],
        [-3.7276e-04, -2.0076e-01,  2.5096e-01,  ...,  9.9699e-01, -5.4226e-01,  1.7926e-01],
        ...
        [ 7.1929e-01, -1.1457e-01,  1.4804e-01,  ...,  5.3051e-01, 7.4839e-01,  7.8224e-02]
    ]]),
    pooler_output=tensor([[-0.6889,  0.4869,  0.9998, -0.9888,  0.9296,  0.8637, ...,  1.0000, -0.7488,  0.9860]]),
    hidden_states=None,
    past_key_values=None,
    attentions=None,
    cross_attentions=None
)</code></pre>
<p>We must focus for now on the <code>last_hidden_state</code> field,
which contains the last layer vector of weights for each token, arguably
the best contextualized representation of the token.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="bu">print</span>(output.last_hidden_state.shape)</span></code></pre>
</div>
<p><code>torch.Size([1, 7, 768])</code></p>
<p>When we print the shape of this field, we obtain again a Pytorch
Tensor: <code>torch.Size([1, 7, 768])</code>. This time, the first
dimension is the batch size, the second is the number of tokens (we have
7 tokens for this example as seen before), and the third, the
dimensionality of the vectors. In the case of BERT-base each token
vector always has a shape of 768. As opposed to the previous tensor,
each of the 7 tokens are not just one integer anymore, but a whole
vector of weights, hence the 3-dimensionality of the tensor.</p>
<div id="callout3" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>When running examples in a BERT pre-trained model, it is advisable to
wrap your code inside a <code>torch.no_grad():</code> context. This is
linked to the fact that BERT is a Neural Network that has been trained
(and can be further finetuned) with the Backpropagation algorithm.
Essentially, this wrapper tells the model that we are not in training
mode, and we are not interested in <em>updating</em> the weights (as it
would happen when training any neural network), because the weights are
already optimal enough. By using this wrapper, we make the model more
efficient as it does not need to calculate the gradients for an eventual
backpropagation step, since we are only interested in what <em>comes
out</em> of the Encoder. So the previous code can be made more efficient
like this:</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="im">import</span> torch </span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>    output <span class="op">=</span> model(<span class="op">**</span>encoded_input)</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>    <span class="bu">print</span>(output)</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>    <span class="bu">print</span>(output.last_hidden_state.shape)</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="bert-as-a-language-model">BERT as a Language Model<a class="anchor" aria-label="anchor" href="#bert-as-a-language-model"></a></h1>
<p>Now that we know how to embedd and run the model to obtain the
representations, we can test the code for our first NLP Task: Language
Modelling (LM). As mentioned before, the main pre-training task of BERT
is LM: calculating the probability of a word based on the known
neighboring words (yes, Word2Vec was also a kind of LM). Obtaining
training data for this task is very cheap, as all we need is millions of
sentences from existing texts, without any labels. In this setting, BERT
encodes a sequence of words, and predicts from a set of English tokens,
what is the most likely token that could be inserted in the
<code>[MASK]</code> position</p>
<figure><img src="../fig/bert1b.png" alt="BERT Language Modeling" class="figure mx-auto d-block"><div class="figcaption">BERT Language Modeling</div>
</figure><p>We can therefore start using BERT as a predictor for word completion,
and the word can be in any position inside the sentence. We will also
learn here how to use the <code>pipeline</code> object, this is very
useful when we only want to use a pre-trained model for predictions (no
need to fine-tune). The <code>pipeline</code> will internally initialize
both model and tokenizer for us. In this case again we use
<code>bert-base-cased</code>, which refers to the vanilla BERT English
model. Once we declared a pipeline, we can feed it with sentences that
contain one masked token at a time (beware that BERT can only predict
one word at a time, since that was its training scheme). For
example:</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> pipeline</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="kw">def</span> pretty_print_outputs(sentences, model_outputs):</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>    <span class="cf">for</span> i, model_out <span class="kw">in</span> <span class="bu">enumerate</span>(model_outputs):</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=====</span><span class="ch">\t</span><span class="st">"</span>,sentences[i])</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>        <span class="cf">for</span> label_scores <span class="kw">in</span> model_out:</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>            <span class="bu">print</span>(label_scores)</span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>nlp <span class="op">=</span> pipeline(task<span class="op">=</span><span class="st">"fill-mask"</span>, model<span class="op">=</span><span class="st">"bert-base-cased"</span>, tokenizer<span class="op">=</span><span class="st">"bert-base-cased"</span>)</span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>sentences <span class="op">=</span> [<span class="st">"Paris is the [MASK] of France"</span>, <span class="st">"I want to eat a cold [MASK] this afternoon"</span>, <span class="st">"Maria [MASK] Groningen"</span>]</span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a>model_outputs <span class="op">=</span> nlp(sentences, top_k<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a>pretty_print_outputs(sentences, model_outputs)</span></code></pre>
</div>
<pre><code>=====	 Paris is the [MASK] of France
{'score': 0.9807965755462646, 'token': 2364, 'token_str': 'capital', 'sequence': 'Paris is the capital of France'}
{'score': 0.004513159394264221, 'token': 6299, 'token_str': 'Capital', 'sequence': 'Paris is the Capital of France'}
{'score': 0.004281804896891117, 'token': 2057, 'token_str': 'center', 'sequence': 'Paris is the center of France'}
{'score': 0.002848200500011444, 'token': 2642, 'token_str': 'centre', 'sequence': 'Paris is the centre of France'}
{'score': 0.0022805952467024326, 'token': 1331, 'token_str': 'city', 'sequence': 'Paris is the city of France'}

=====	 I want to eat a cold [MASK] this afternoon
{'score': 0.19168031215667725, 'token': 13473, 'token_str': 'pizza', 'sequence': 'I want to eat a cold pizza this afternoon'}
{'score': 0.14800849556922913, 'token': 25138, 'token_str': 'turkey', 'sequence': 'I want to eat a cold turkey this afternoon'}
{'score': 0.14620967209339142, 'token': 14327, 'token_str': 'sandwich', 'sequence': 'I want to eat a cold sandwich this afternoon'}
{'score': 0.09997560828924179, 'token': 5953, 'token_str': 'lunch', 'sequence': 'I want to eat a cold lunch this afternoon'}
{'score': 0.06001955270767212, 'token': 4014, 'token_str': 'dinner', 'sequence': 'I want to eat a cold dinner this afternoon'}

=====	 Maria [MASK] Groningen
{'score': 0.24399833381175995, 'token': 117, 'token_str': ',', 'sequence': 'Maria, Groningen'}
{'score': 0.12300779670476913, 'token': 1104, 'token_str': 'of', 'sequence': 'Maria of Groningen'}
{'score': 0.11991506069898605, 'token': 1107, 'token_str': 'in', 'sequence': 'Maria in Groningen'}
{'score': 0.07722211629152298, 'token': 1306, 'token_str': '##m', 'sequence': 'Mariam Groningen'}
{'score': 0.0632941722869873, 'token': 118, 'token_str': '-', 'sequence': 'Maria - Groningen'}
</code></pre>
<p>When we call the <code>nlp</code> pipeline, requesting to return the
<code>top_k</code> most likely suggestions to complete the provided
sentences (in this case <code>k=5</code>). The pipeline returns a list
of outputs as python dictionaries. Depending on the task, the fields of
the dictionary will differ. In this case, the <code>fill-mask</code>
task returns a score (between 0 and 1, the higher the score the more
likely the token is), a tokenId, and its corresponding string, as well
as the full “unmasked” sequence.</p>
<p>In the list of outputs we can observe: the first example shows
correctly that the missing token in the first sentence is
<em>capital</em>, the second example is a bit more ambiguous, but the
model at least uses the context to correctly predict a series of items
that can be eaten (unfortunately, none of its suggestions sound very
tasty); finally, the third example gives almost no useful context so the
model plays it safe and only suggests prepositions or punctuation. This
already shows some of the weaknesses of the approach.</p>
<p>We will next see the case of combining BERT with a classifier on
top.</p>
</div>
<div class="section level1">
<h1 id="bert-for-text-classification">BERT for Text Classification<a class="anchor" aria-label="anchor" href="#bert-for-text-classification"></a></h1>
<p>The task of text classification is assigning a label to a whole
sequence of tokens, for example a sentence. With the parameter
<code>task="text_classification"</code> the <code>pipeline()</code>
function will load the base model and automatically add a linear layer
with a softmax on top. This layer can be fine-tuned with our own labeled
data or we can also directly load the fully pre-trained text
classification models that are already available in HuggingFace.</p>
<figure><img src="../fig/bert4.png" alt="BERT as an Emotion Classifier" class="figure mx-auto d-block"><div class="figcaption">BERT as an Emotion Classifier</div>
</figure><p>Let’s see the example of a ready pre-trained emotion classifier based
on <code>RoBERTa</code> model. This model was fine-tuned in the Go
emotions <a href="https://huggingface.co/datasets/google-research-datasets/go_emotions" class="external-link">dataset</a>,
taken from English Reddit and labeled for 28 different emotions at the
sentence level. The fine-tuned model is called <a href="https://huggingface.co/SamLowe/roberta-base-go_emotions" class="external-link">roberta-base-go_emotions</a>.
This model takes a sentence as input and ouputs a probability
distribution over the 28 possible emotions that might be conveyed in the
text. For example:</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>classifier <span class="op">=</span> pipeline(task<span class="op">=</span><span class="st">"text-classification"</span>, model<span class="op">=</span><span class="st">"SamLowe/roberta-base-go_emotions"</span>, top_k<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>sentences <span class="op">=</span> [<span class="st">"I am not having a great day"</span>, <span class="st">"This is a lovely and innocent sentence"</span>, <span class="st">"Maria loves Groningen"</span>]</span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>model_outputs <span class="op">=</span> classifier(sentences)</span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>pretty_print_outputs(sentences, model_outputs)</span></code></pre>
</div>
<pre><code>=====	 I am not having a great day
{'label': 'disappointment', 'score': 0.46669483184814453}
{'label': 'sadness', 'score': 0.39849498867988586}
{'label': 'annoyance', 'score': 0.06806594133377075}

=====	 This is a lovely and innocent sentence
{'label': 'admiration', 'score': 0.6457845568656921}
{'label': 'approval', 'score': 0.5112180113792419}
{'label': 'love', 'score': 0.09214121848344803}

=====	 Maria loves Groningen
{'label': 'love', 'score': 0.8922032117843628}
{'label': 'neutral', 'score': 0.10132959485054016}
{'label': 'approval', 'score': 0.02525361441075802}</code></pre>
<p>This code outputs again a list of dictionaries with the
<code>top-k</code> (<code>k=3</code>) emotions that each of the two
sentences convey. In this case, the first sentence evokes (in order of
likelihood) <em>dissapointment</em>, <em>sadness</em> and
<em>annoyance</em>; whereas the second sentence evokes <em>love</em>,
<em>neutral</em> and <em>approval</em>. Note however that the likelihood
of each prediction decreases dramatically below the top choice, so
perhaps this specific classifier is only useful for the top emotion.</p>
<div id="callout4" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>Finetunning BERT is very cheap, because we only need to train the
<em>classifier</em> layer, a very small neural network, that can learn
to choose between the classes (labels) for your custom classification
problem, without needing a big amount of annotated data. This classifier
is just a one-layer neural layer with a softmax that assigns a score
that can be translated to the probability over a set of labels, given
the input features provided by BERT, which <em>encodes</em> the meaning
of the entire sequence in its hidden states.</p>
</div>
</div>
</div>
<figure><img src="../fig/bert4b.png" alt="BERT as an Emotion Classifier" class="figure mx-auto d-block"><div class="figcaption">BERT as an Emotion Classifier</div>
</figure></div>
<div class="section level1">
<h1 id="understanding-bert-architecture">Understanding BERT Architecture<a class="anchor" aria-label="anchor" href="#understanding-bert-architecture"></a></h1>
<p>This will help to understand some of the strengths and weaknesses of
using BERT-based classifiers.</p>
<div class="section level2">
<h2 id="tokenizer-and-embedder">Tokenizer and Embedder<a class="anchor" aria-label="anchor" href="#tokenizer-and-embedder"></a></h2>
<p>Let’s revisit the tokenizer to better grasp how it is working. The
tokenization step might seem trivial but in reality models’ tokenizers
make a big difference in the final results of your classifiers,
depending on the task you are trying to solve. Understanding the
tokenizer of each model (as well as the model type!) can save us a lot
of debugging when we work with our custom problem.</p>
<p>We will feed again a sentence into the tokenizer to observe how it
outputs a sequence of vectors (also called a <em>tensor</em>: by
convention, a vector is a sequence of scalar numbers, a matrix is a
2-dimensional sequence and a tensor is a N-dimensional sequence of
numbers), each one of them representing a wordPiece:</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="co"># Feed text into the tokenizer </span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>text <span class="op">=</span> <span class="st">"Maria's passion for music is clearly heard in every note and every enchanting melody."</span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>encoded_input <span class="op">=</span> tokenizer(text, return_tensors<span class="op">=</span><span class="st">'pt'</span>)</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>token_ids <span class="op">=</span> <span class="bu">list</span>(encoded_input.input_ids[<span class="dv">0</span>].detach().numpy())</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>string_tokens <span class="op">=</span> tokenizer.convert_ids_to_tokens(token_ids)</span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a><span class="bu">print</span>(string_tokens)</span></code></pre>
</div>
<p><code>['[CLS]', 'Maria', "'", 's', 'passion', 'for', 'music', 'is', 'clearly', 'heard', 'in', 'every', 'note', 'and', 'every', 'en', '##chan', '##ting', 'melody', '.', '[SEP]']</code></p>
<p>This shows a list of token IDs, as we saw with our first example,
this time the list consists of 21 BERT tokens.</p>
<p>When inspecting the string tokens, we see that most “words” were
converted into a single token, however <em>enchanting</em> was splitted
into three sub-tokens: <code>'en', '##chan', '##ting'</code> the
hashtags indicate wether a sub-token was part of a bigger word or not,
this is useful to recover the human-readable strings later. The
<code>[CLS]</code> token was added at a beginning and is intended to
represent the meaning of the whole sequence, likewise the
<code>[SEP]</code> token was added to indicate that it is where the
sentence ends.</p>
<p>The next step is to give the sequence of tokens to the Encoder which
processes it through the transformer layers and outputs a sequence of
dense vectors:</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>    output <span class="op">=</span> model(<span class="op">**</span>encoded_input)</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>    <span class="bu">print</span>(output.last_hidden_state.shape)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>    <span class="bu">print</span>(output.last_hidden_state[<span class="dv">0</span>][<span class="dv">0</span>])</span></code></pre>
</div>
<p><code>torch.Size([1, 21, 768])</code></p>
<pre><code>tensor([-5.3755e-02, -1.1100e-01, -8.8204e-02, -1.1233e-01,  8.1979e-02,
        -7.2656e-03,  2.5323e-01, -3.0361e-01,  1.7344e-01, -1.1212e+00, ...    </code></pre>
<p>We chose to print here the vector representation of
<code>[CLS]</code>: by indexing the <code>last_hidden_state[0]</code> we
access to the first batch (21 vectors of 768-dimensionality), and by
again indexing <code>last_hidden_state[0][0]</code> we access the first
of the last_hidden_vectors, which as we saw in the token strings, belong
to <code>[CLS]</code> and is there to represent the whole sequence. We
only see a lot of fine-tuned weights which are not very informative in
their own, but the full-vectors are meaningful within the embedding
space, which emulates some aspects of linguistic meaning.</p>
<div id="callout5" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>In the case of wanting to obtain a single vector for
<em>enchanting</em>, you can average the three vectors that belong to
the token pieces that ultimately form that word. For example:</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>tok_en <span class="op">=</span> output.last_hidden_state[<span class="dv">0</span>][<span class="dv">15</span>].detach().numpy()</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>tok_chan <span class="op">=</span> output.last_hidden_state[<span class="dv">0</span>][<span class="dv">16</span>].detach().numpy()</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a>tok_ting <span class="op">=</span> output.last_hidden_state[<span class="dv">0</span>][<span class="dv">17</span>].detach().numpy()</span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a>tok_enchanting <span class="op">=</span> np.mean([tok_en, tok_chan, tok_ting], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a>tok_enchanting.shape</span></code></pre>
</div>
<p>We use the functions <code>detach().numpy()</code> to bring the
values from the Pytorch execution environment (for example a GPU) into
the main python thread and treat it as a numpy vector for convenvience.
Then, since we are dealing with three numpy vectors we can average the
three of them and end op with a single <code>enchanting</code> vector of
768-dimensions representing the average of
<code>'en', '##chan', '##ting'</code>.</p>
</div>
</div>
</div>
<p>We can use the same method to encode two other sentences containing
the word <em>note</em> to see how BERT actually handles polysemy
(<em>note</em> means something very different in each sentence) thanks
to the representation of each word now being contextualized instead of
isolated as was the case with word2vec.</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="co"># Search for the index of 'note' and obtain its vector from the sequence</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>note_index_1 <span class="op">=</span> string_tokens.index(<span class="st">"note"</span>)</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>note_vector_1 <span class="op">=</span> output.last_hidden_state[<span class="dv">0</span>][note_index_1].detach().numpy()</span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>note_token_id_1 <span class="op">=</span> token_ids[note_index_1]</span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a><span class="bu">print</span>(note_index_1, note_token_id_1, string_tokens)</span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a><span class="bu">print</span>(note_vector_1[:<span class="dv">5</span>])</span></code></pre>
</div>
<p>We are basically printing the tokenized sentence from the previous
example and showing the index of the token <code>note</code> in the list
of tokens. We are also printing the tokenID assigned to this token and
the list of tokens. Finally, the last print shows the first five
dimensions of the vector representing the token <code>note</code>.</p>
<pre><code>12 3805 ['[CLS]', 'Maria', "'", 's', 'passion', 'for', 'music', 'is', 'clearly', 'heard', 'in', 'every', 'note', 'and', 'every', 'en', '##chan', '##ting', 'melody', '.', '[SEP]']
[0.15780845 0.38866335 0.41498923 0.03389652 0.40278202]</code></pre>
<p>Let’s encode now another sentence, also containing the word
<code>note</code>, and confirm that the same token string, with the same
assigned tokenID holds a vector with different weights:</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="co"># Encode and then take the 'note' token from the second sentence</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>note_text_2 <span class="op">=</span> <span class="st">"I could not buy milk in the supermarket because the bank note I wanted to use was fake."</span></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>encoded_note_2 <span class="op">=</span> tokenizer(note_text_2, return_tensors<span class="op">=</span><span class="st">"pt"</span>)</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>token_ids <span class="op">=</span> <span class="bu">list</span>(encoded_note_2.input_ids[<span class="dv">0</span>].detach().numpy())</span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>string_tokens_2 <span class="op">=</span> tokenizer.convert_ids_to_tokens(token_ids)</span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a>note_index_2 <span class="op">=</span> string_tokens_2.index(<span class="st">"note"</span>)</span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a>note_vector_2 <span class="op">=</span> model(<span class="op">**</span>encoded_note_2).last_hidden_state[<span class="dv">0</span>][note_index_2].detach().numpy()</span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a>note_token_id_2 <span class="op">=</span> token_ids[note_index_2]</span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" tabindex="-1"></a><span class="bu">print</span>(note_index_2, note_token_id_2, string_tokens_2)</span>
<span id="cb21-12"><a href="#cb21-12" tabindex="-1"></a><span class="bu">print</span>(note_vector_2[:<span class="dv">5</span>])</span></code></pre>
</div>
<pre><code>12 3805 ['[CLS]', 'I', 'could', 'not', 'buy', 'milk', 'in', 'the', 'supermarket', 'because', 'the', 'bank', 'note', 'I', 'wanted', 'to', 'use', 'was', 'fake', '.', '[SEP]']
[ 0.5003222   0.653664    0.22919582 -0.32637975  0.52929205]</code></pre>
<p>To be sure, we can compute the cosine similarity of the word
<em>note</em> in the first sentence and the word <em>note</em> in the
second sentence confirming that they are indeed two different
representations, even when in both cases they have the same token-id and
they are the 12th token of the sentence:</p>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="im">from</span> sklearn.metrics.pairwise <span class="im">import</span> cosine_similarity</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>vector1 <span class="op">=</span> np.array(note_vector_1).reshape(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>vector2 <span class="op">=</span> np.array(note_vector_2).reshape(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>similarity <span class="op">=</span> cosine_similarity(vector1, vector2)</span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Cosine Similarity 'note' vs 'note': </span><span class="sc">{</span>similarity[<span class="dv">0</span>][<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span></code></pre>
</div>
<p>With this small experiment, we have confirmed that the Encoder
produces context-dependent word representations, ass opposed to
Word2Vec, where <em>note</em> would always have the same vector no
matter where it appeared.</p>
</div>
<div class="section level2">
<h2 id="the-attention-mechanism">The Attention Mechanism<a class="anchor" aria-label="anchor" href="#the-attention-mechanism"></a></h2>
<p>The original attention mechanism (remember this was developed for
language translation) is a component in between the Encoder and the
Decoder that helps the model to <em>align</em> the important information
from the input sequence in order to generate a more accurate token in
the output sequence:</p>
<figure><img src="../fig/trans3.png" alt="The Encoder-Decoder Attention Mechanism" class="figure mx-auto d-block"><div class="figcaption">The Encoder-Decoder Attention Mechanism</div>
</figure><p>In the example above, the attention puts more weight in the input
<em>Groningen</em>, so the decoder uses that information to
<em>know</em> that is should generate <em>Groningen</em>. Note that if
the decoder based it’s next word probability just on the sequence “Maria
houdt van …”, it could basically generate any word and still sound
natural. However, it is thanks to the attention mechanism that it
preserves the meaning of the input sequence.</p>
<p>Attention is a neural layer, therefore it can also be plugged-in
within the Encoder, this is called <strong>self-attention</strong> since
the mechanism will look at the interactions between the input sequence
itself (measure inportance between input sequence tokens vs input
sequence tokens). This is how BERT uses (self-) attention, which is very
useful to capture longer-range word dependencies such as correference,
where, for example, a pronoun can be linked to the noun it refers to
previously in the same sentence. See the following example:</p>
<figure><img src="../fig/trans5.png" alt="The Encoder Self-Attention Mechanism" class="figure mx-auto d-block"><div class="figcaption">The Encoder Self-Attention Mechanism</div>
</figure><p>There are two sentences, in each one the pronoun “it” refers to a
different noun, “animal” or “street”, and this is completely depending
on the sentence context. Thanks to the self-attention BERT relates the
pronoun to its relevant correferent.</p>
<p>For this reason BERT is not only useful as a text classifier but also
for individual token classification tasks.</p>
</div>
</div>
<div class="section level1">
<h1 id="bert-for-token-classification">BERT for Token Classification<a class="anchor" aria-label="anchor" href="#bert-for-token-classification"></a></h1>
<p>Just as we plugged in a trainable text classifier layer, we can add a
token-level classifier that assigns a class to each of the tokens
encoded by a transformer (as opposed to one label for the whole
sequence). A specific example of this task is Named Entity Recognition,
but you can basically define any task that requires to
<em>highlight</em> sub-strings of text and classify them using this
technique.</p>
<div class="section level2">
<h2 id="named-entity-recognition">Named Entity Recognition<a class="anchor" aria-label="anchor" href="#named-entity-recognition"></a></h2>
<p>Named Entity Recognition (NER) is the task of recognizing mentions of
real-world entities inside a text. The concept of
<strong>Entity</strong> includes proper names that unequivocally
identify a unique individual (PER), place (LOC), organization (ORG), or
other object/name (MISC). Depending on the domain, the concept can
expanded to recognize other unique (and more conceptual) entities such
as DATE, MONEY, WORK_OF_ART, DISEASE, PROTEIN_TYPE, etcetera…</p>
<p>In terms of NLP, this boils down to classifying each token into a
series of labels (<code>PER</code>, <code>LOC</code>, <code>ORG</code>,
<code>O</code>[no-entity] ). Since a single entity can be expressed with
multiple words (e.g. New York) the usual notation used for labeling the
text is IOB (<strong>I</strong>nner <strong>O</strong>ut
<strong>B</strong>eginnig of entity) notations which identifies the
limits of each entity tokens. For example:</p>
<figure><img src="../fig/bert5.png" alt="BERT as an NER Classifier" class="figure mx-auto d-block"><div class="figcaption">BERT as an NER Classifier</div>
</figure><p>This is a typical sequence classification problem where an imput
sequence must be fully mapped into an output sequence of labels with
global constraints (for example, there can’t be an inner I-LOC label
before a beginning B-LOC label). Since the labels of the tokens are
context dependent, a language model with attention mechanism such as
BERT is very beneficial for a task like NER.</p>
<p>Because this is one of the core tasks in NLP, there are dozens of
pre-trained NER classifiers in HuggingFace that you can use right away.
We use once again the <code>pipeline()</code> to run the model for
predictions in your custom data, in this case with
<code>task="ner"</code>. For example:</p>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> AutoTokenizer, AutoModelForTokenClassification</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> pipeline</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a>tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(<span class="st">"dslim/bert-base-NER"</span>)</span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a>model <span class="op">=</span> AutoModelForTokenClassification.from_pretrained(<span class="st">"dslim/bert-base-NER"</span>)</span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" tabindex="-1"></a>ner_classifier <span class="op">=</span> pipeline(<span class="st">"token-classification"</span>, model<span class="op">=</span>model, tokenizer<span class="op">=</span>tokenizer)</span>
<span id="cb24-8"><a href="#cb24-8" tabindex="-1"></a>example <span class="op">=</span> <span class="st">"My name is Wolfgang Schmid and I live in Berlin"</span></span>
<span id="cb24-9"><a href="#cb24-9" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" tabindex="-1"></a>ner_results <span class="op">=</span> ner_classifier(example)</span>
<span id="cb24-11"><a href="#cb24-11" tabindex="-1"></a><span class="cf">for</span> nr <span class="kw">in</span> ner_results:</span>
<span id="cb24-12"><a href="#cb24-12" tabindex="-1"></a>    <span class="bu">print</span>(nr)</span></code></pre>
</div>
<p>The code prints the following:</p>
<pre><code>{'entity': 'B-PER', 'score': 0.9996068, 'index': 4, 'word': 'Wolfgang', 'start': 11, 'end': 19}
{'entity': 'I-PER', 'score': 0.999582, 'index': 5, 'word': 'Sc', 'start': 20, 'end': 22}
{'entity': 'I-PER', 'score': 0.9990482, 'index': 6, 'word': '##hm', 'start': 22, 'end': 24}
{'entity': 'I-PER', 'score': 0.9951691, 'index': 7, 'word': '##id', 'start': 24, 'end': 26}
{'entity': 'B-LOC', 'score': 0.99956733, 'index': 12, 'word': 'Berlin', 'start': 41, 'end': 47}</code></pre>
<p>In this case the output of the pipeline is a list of dictionaries,
each one representing only entity <code>IOB</code> labels at the BERT
token level. IMPORTANT: this list is per wordPiece and NOT per <em>human
word</em> even if the provided text is pre-tokenized. You can assume all
of the tokens that don’t appear in the output were labeled as no-entity,
that is <code>"O"</code>. To recover the full-word entities you can
initialize the pipeline with
<code>aggregation_strategy="first"</code>:</p>
<div class="codewrapper sourceCode" id="cb26">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>ner_classifier <span class="op">=</span> pipeline(<span class="st">"token-classification"</span>, model<span class="op">=</span>model, tokenizer<span class="op">=</span>tokenizer, aggregation_strategy<span class="op">=</span><span class="st">"first"</span>)</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>example <span class="op">=</span> <span class="st">"My name is Wolfgang Schmid and I live in Berlin"</span></span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a>ner_results <span class="op">=</span> ner_classifier(example)</span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a><span class="cf">for</span> nr <span class="kw">in</span> ner_results:</span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a>    <span class="bu">print</span>(nr)</span></code></pre>
</div>
<p>The code now prints the following:</p>
<pre><code>{'entity_group': 'PER', 'score': 0.9995944, 'word': 'Wolfgang Schmid', 'start': 11, 'end': 26}
{'entity_group': 'LOC', 'score': 0.99956733, 'word': 'Berlin', 'start': 41, 'end': 47}</code></pre>
<p>As you can see, entities aggregated at the Span Leven (instead of the
Token Level). Word pieces are merged back into <em>human words</em> and
also multiword entities are assigned a single entity label unifying the
<code>IOB</code> labels into one. Depending on your use case you can
request the pipeline to give different
<code>aggregation_strateg[ies]</code>. More info about the pipeline can
be found <a href="https://huggingface.co/docs/transformers/main_classes/pipelines" class="external-link">here</a>.</p>
<p>The next step is crucial: evaluate how does the pre-trained model
actually performs in <strong>your dataset</strong>. This is important
since the fine-tuned model could be overfitted to other custom
benchmarks that do not share the characteristics of your dataset.</p>
<p>To observe this, we can first see the performance on the test portion
of the dataset in which this classifier was trained, and then evaluate
the same pre-trained classifier on a NER dataset form a different
domain.</p>
</div>
</div>
<div class="section level1">
<h1 id="end-here--">———- END HERE ??? ———-<a class="anchor" aria-label="anchor" href="#end-here--"></a></h1>
<p>The rest is more advanced content (still I leave it here just in case
for now).</p>
<div class="section level2">
<h2 id="testing-on-conll-03-benchmark">Testing on CoNLL-03 Benchmark<a class="anchor" aria-label="anchor" href="#testing-on-conll-03-benchmark"></a></h2>
<p>This model was trained on the CoNLL-03 dataset, therefore we can
corroborate how it performs using the test portion of this dataset. To
get the data we can use the <code>datasets</code> library which is also
part of theHuggingFace landscape</p>
<pre><code>pip install datasets</code></pre>
<div class="codewrapper sourceCode" id="cb29">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="im">from</span> datasets <span class="im">import</span> load_dataset</span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a>conll03_data <span class="op">=</span> load_dataset(<span class="st">"eriktks/conll2003"</span>, split<span class="op">=</span><span class="st">"test"</span>, trust_remote_code<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a>conll03_data</span></code></pre>
</div>
<p>This shows the features and number of records of the CoNLL-03
Dataset. Next we can observe which labels we have in the data</p>
<div class="codewrapper sourceCode" id="cb30">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>conll03_data.features[<span class="st">'ner_tags'</span>]</span></code></pre>
</div>
<p>As expected, the labels are in IOB notation, where each label
corresponds to one word in the dataset, however the dataset contains the
labelIDs and we need to map them to their string representations. We can
double check this by looking at one of the records of the dataset:</p>
<div class="codewrapper sourceCode" id="cb31">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="kw">def</span> labelid2str(label_int):</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>    d <span class="op">=</span> conll03_data.features[<span class="st">'ner_tags'</span>].feature._int2str</span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a>    <span class="cf">return</span> d[label_int]</span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a>example_id <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a><span class="bu">print</span>(conll03_data[<span class="st">'tokens'</span>][example_id])</span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a><span class="bu">print</span>(conll03_data[<span class="st">'ner_tags'</span>][example_id])</span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a><span class="bu">print</span>([labelid2str(tag) <span class="cf">for</span> tag <span class="kw">in</span> conll03_data[<span class="st">'ner_tags'</span>][example_id]])</span></code></pre>
</div>
<p>These are the Gold Labels of the dataset. We can use our pre-trained
BERT model to predict the labels for each example and compare the
outputs to the gold labels provided in the data.</p>
<div class="section level3">
<h3 id="predictions-using-pipeline">Predictions using Pipeline<a class="anchor" aria-label="anchor" href="#predictions-using-pipeline"></a></h3>
<p>This could be done using the pipeline as we have been doing so far,
example by example:</p>
<div class="codewrapper sourceCode" id="cb32">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a></span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> AutoTokenizer, AutoModelForTokenClassification</span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> pipeline</span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a><span class="kw">def</span> get_gold_labels(label_ids):</span>
<span id="cb32-6"><a href="#cb32-6" tabindex="-1"></a>    <span class="cf">return</span> [labelid2str(tag) <span class="cf">for</span> tag <span class="kw">in</span> label_ids]</span>
<span id="cb32-7"><a href="#cb32-7" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" tabindex="-1"></a><span class="kw">def</span> token_to_spans(tokens):</span>
<span id="cb32-10"><a href="#cb32-10" tabindex="-1"></a>    token2spans <span class="op">=</span> {}</span>
<span id="cb32-11"><a href="#cb32-11" tabindex="-1"></a>    char_start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb32-12"><a href="#cb32-12" tabindex="-1"></a>    <span class="cf">for</span> i, tok <span class="kw">in</span> <span class="bu">enumerate</span>(tokens):</span>
<span id="cb32-13"><a href="#cb32-13" tabindex="-1"></a>        tok_end <span class="op">=</span> char_start <span class="op">+</span> <span class="bu">len</span>(tok)</span>
<span id="cb32-14"><a href="#cb32-14" tabindex="-1"></a>        token2spans[i] <span class="op">=</span> (char_start, tok_end)</span>
<span id="cb32-15"><a href="#cb32-15" tabindex="-1"></a>        char_start <span class="op">=</span> tok_end <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb32-16"><a href="#cb32-16" tabindex="-1"></a>    <span class="cf">return</span> token2spans</span>
<span id="cb32-17"><a href="#cb32-17" tabindex="-1"></a></span>
<span id="cb32-18"><a href="#cb32-18" tabindex="-1"></a><span class="kw">def</span> get_iob_from_aggregated(tokenized_sentence, entities):</span>
<span id="cb32-19"><a href="#cb32-19" tabindex="-1"></a>    <span class="co"># Initialize all labels empty</span></span>
<span id="cb32-20"><a href="#cb32-20" tabindex="-1"></a>    iob_labels <span class="op">=</span> [<span class="st">'O'</span>] <span class="op">*</span> <span class="bu">len</span>(tokenized_sentence)</span>
<span id="cb32-21"><a href="#cb32-21" tabindex="-1"></a>    <span class="co"># Get Token &lt;-&gt; Chars Mapping</span></span>
<span id="cb32-22"><a href="#cb32-22" tabindex="-1"></a>    tok2spans <span class="op">=</span> token_to_spans(tokenized_sentence)</span>
<span id="cb32-23"><a href="#cb32-23" tabindex="-1"></a>    start2tok <span class="op">=</span> {v[<span class="dv">0</span>]:k <span class="cf">for</span> k, v <span class="kw">in</span> tok2spans.items()}</span>
<span id="cb32-24"><a href="#cb32-24" tabindex="-1"></a>    end2tok <span class="op">=</span> {v[<span class="dv">1</span>]:k <span class="cf">for</span> k, v <span class="kw">in</span> tok2spans.items()}</span>
<span id="cb32-25"><a href="#cb32-25" tabindex="-1"></a>    <span class="co"># Iterate over each entity to populate labels</span></span>
<span id="cb32-26"><a href="#cb32-26" tabindex="-1"></a>    <span class="cf">for</span> entity <span class="kw">in</span> entities:</span>
<span id="cb32-27"><a href="#cb32-27" tabindex="-1"></a>        label <span class="op">=</span> entity[<span class="st">'entity_group'</span>]</span>
<span id="cb32-28"><a href="#cb32-28" tabindex="-1"></a>        token_start <span class="op">=</span> start2tok.get(entity[<span class="st">'start'</span>])</span>
<span id="cb32-29"><a href="#cb32-29" tabindex="-1"></a>        token_end <span class="op">=</span> end2tok.get(entity[<span class="st">'end'</span>])</span>
<span id="cb32-30"><a href="#cb32-30" tabindex="-1"></a>        </span>
<span id="cb32-31"><a href="#cb32-31" tabindex="-1"></a>        <span class="cf">if</span> token_start <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb32-32"><a href="#cb32-32" tabindex="-1"></a>            iob_labels[token_start] <span class="op">=</span> <span class="ss">f'B-</span><span class="sc">{</span>label<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb32-33"><a href="#cb32-33" tabindex="-1"></a>            <span class="cf">if</span> token_end <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb32-34"><a href="#cb32-34" tabindex="-1"></a>                <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(token_start<span class="op">+</span><span class="dv">1</span>, token_end<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb32-35"><a href="#cb32-35" tabindex="-1"></a>                    iob_labels[i] <span class="op">=</span> <span class="ss">f'I-</span><span class="sc">{</span>label<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb32-36"><a href="#cb32-36" tabindex="-1"></a>    </span>
<span id="cb32-37"><a href="#cb32-37" tabindex="-1"></a>    <span class="cf">return</span> iob_labels</span>
<span id="cb32-38"><a href="#cb32-38" tabindex="-1"></a></span>
<span id="cb32-39"><a href="#cb32-39" tabindex="-1"></a>tokenizer <span class="op">=</span> AutoTokenizer.from_pretrained(<span class="st">"dslim/bert-base-NER"</span>)</span>
<span id="cb32-40"><a href="#cb32-40" tabindex="-1"></a>model <span class="op">=</span> AutoModelForTokenClassification.from_pretrained(<span class="st">"dslim/bert-base-NER"</span>)</span>
<span id="cb32-41"><a href="#cb32-41" tabindex="-1"></a></span>
<span id="cb32-42"><a href="#cb32-42" tabindex="-1"></a>example <span class="op">=</span> conll03_data[<span class="st">'tokens'</span>][example_id]</span>
<span id="cb32-43"><a href="#cb32-43" tabindex="-1"></a>example_str <span class="op">=</span> <span class="st">" "</span>.join(example)</span>
<span id="cb32-44"><a href="#cb32-44" tabindex="-1"></a></span>
<span id="cb32-45"><a href="#cb32-45" tabindex="-1"></a>ner_classifier <span class="op">=</span> pipeline(<span class="st">"ner"</span>, model<span class="op">=</span>model, tokenizer<span class="op">=</span>tokenizer, aggregation_strategy<span class="op">=</span><span class="st">"first"</span>)</span>
<span id="cb32-46"><a href="#cb32-46" tabindex="-1"></a>predictions <span class="op">=</span> ner_classifier(example_str)</span>
<span id="cb32-47"><a href="#cb32-47" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SENTENCE:"</span>, example_str)</span>
<span id="cb32-48"><a href="#cb32-48" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"PREDICTED:"</span>, get_iob_from_aggregated(example, predictions))</span>
<span id="cb32-49"><a href="#cb32-49" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"GOLD:"</span>, get_gold_labels(conll03_data[<span class="st">'ner_tags'</span>][example_id]))</span></code></pre>
</div>
<p>Now that we understand how to get a list of Predicted labels for one
example we can run the model for the whole test data:</p>
<div class="codewrapper sourceCode" id="cb33">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a>all_predictions <span class="op">=</span> []</span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a><span class="cf">for</span> example <span class="kw">in</span> conll03_data[<span class="st">'tokens'</span>]:</span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a>    output <span class="op">=</span> ner_classifier(<span class="st">" "</span>.join(example))</span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a>    predictions <span class="op">=</span> get_iob_from_aggregated_simple(example, output)</span>
<span id="cb33-5"><a href="#cb33-5" tabindex="-1"></a>    all_predictions.append(predictions)</span>
<span id="cb33-6"><a href="#cb33-6" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" tabindex="-1"></a>gold_labels <span class="op">=</span> [get_gold_labels(lbl) <span class="cf">for</span> lbl <span class="kw">in</span> conll03_data[<span class="st">'ner_tags'</span>]]</span></code></pre>
</div>
<p>We can use the <code>seqeval</code> package to directly evaluate the
outputs:</p>
<div class="codewrapper sourceCode" id="cb34">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="im">from</span> seqeval.metrics <span class="im">import</span> classification_report</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a>report <span class="op">=</span> classification_report(gold_labels, all_predictions)</span>
<span id="cb34-4"><a href="#cb34-4" tabindex="-1"></a><span class="bu">print</span>(report)</span></code></pre>
</div>
<p>The three most basic metrics for NLP classifiers are traditionally
Precision, Recall and F1 score. They come from the Information
Extraction field and roughly they aim to measure the following: -
<strong>Precision (P):</strong> From the predicted entities, how many of
them are correct (i.e. match the gold labels)? - <strong>Recall
(R):</strong> From the known gold entities, how many of them were
predicted by the model? - <strong>F1 Score (F1):</strong> the harmonic
mean of precison and recall, which aims to provide a balance between
both metrics. It has two variants: the Micro-F1 which treats all errors
equally, being the same as measuring Accuracy; and Macro-F1, which aims
to show the model performance taking into account the label
distribution, this is normally the score reported through main
benchmarks as it shows better the model’s weaknesses across classes.</p>
</div>
</div>
<div class="section level2">
<h2 id="using-a-pre-trained-model-on-litbank">Using a Pre-trained Model on LitBank<a class="anchor" aria-label="anchor" href="#using-a-pre-trained-model-on-litbank"></a></h2>
<p>We can of course also use the pre-trained NER classifier with any
<strong>custom dataset</strong>, it will just need come pre- and
post-processing steps to make it work. For this example, we will use the
<a href="https://github.com/dbamman/litbank" class="external-link">LitBank</a> corpus, an
annotated dataset of 100 works of English-language fiction to support
tasks in natural language processing and the computational humanities.
Specifically they have human annotations of entities on these books. We
can measure how good is this pre-trained classifier by making the model
predict the entities inside the text and them compare the outputs with
the humam annotations. The NER portion of the dataset we will use is the
tabulated data from <a href="https://github.com/dbamman/litbank/tree/master/entities/tsv" class="external-link">here</a>
and one example looks like this:</p>
<table class="table"><thead><tr class="header"><th>Index</th>
<th>Token</th>
<th>IOB-1</th>
<th>IOB-2</th>
<th>IOB-3</th>
<th>IOB-4</th>
</tr></thead><tbody><tr class="odd"><td>1</td>
<td>CHAPTER</td>
<td>O</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr><tr class="even"><td>2</td>
<td>I</td>
<td>O</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr><tr class="odd"><td>3</td>
<td>In</td>
<td>O</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr><tr class="even"><td>4</td>
<td>Chancery</td>
<td>B-FAC</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr><tr class="odd"><td>5</td>
<td>London</td>
<td>B-GPE</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr><tr class="even"><td>6</td>
<td>.</td>
<td>O</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr></tbody></table><p>It contains the information of 4 annotators, this is very useful
interannotator agreement, a technique in computational linguistics for
validating the correctness and consistency of the dataset. Yes! Humans
are wrong too all the time when labeling! For simplicity, we will assume
we only have the information from annotator 1 and take that as our
ground truth.</p>
<p>The format of the dataset resembles the conll format, a widely used
format in computational linguistics for token-based annotations. Another
important aspect to observe is that they have other labels for entities.
The pre-trained model we chose only labels PER, LOC, ORG and MISC. We
can translate FAC and GPE to LOC label as they are only more
fine-grained occurrences of locations which our model should recognize
as such. To read the data we can use the following function:</p>
<div class="codewrapper sourceCode" id="cb35">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a></span>
<span id="cb35-2"><a href="#cb35-2" tabindex="-1"></a><span class="kw">def</span> quick_conll_reader(filepath):</span>
<span id="cb35-3"><a href="#cb35-3" tabindex="-1"></a>    all_sentences, all_labels <span class="op">=</span> [], []</span>
<span id="cb35-4"><a href="#cb35-4" tabindex="-1"></a>    sent_txt, sent_lbl <span class="op">=</span> [], []</span>
<span id="cb35-5"><a href="#cb35-5" tabindex="-1"></a>    label_vocab <span class="op">=</span> {}</span>
<span id="cb35-6"><a href="#cb35-6" tabindex="-1"></a>    gold_label_column <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb35-7"><a href="#cb35-7" tabindex="-1"></a>    label_translator <span class="op">=</span> {</span>
<span id="cb35-8"><a href="#cb35-8" tabindex="-1"></a>        <span class="st">"B-FAC"</span>: <span class="st">"O"</span>,</span>
<span id="cb35-9"><a href="#cb35-9" tabindex="-1"></a>        <span class="st">"I-FAC"</span>: <span class="st">"O"</span>,</span>
<span id="cb35-10"><a href="#cb35-10" tabindex="-1"></a>        <span class="st">"B-GPE"</span>: <span class="st">"B-LOC"</span>,</span>
<span id="cb35-11"><a href="#cb35-11" tabindex="-1"></a>        <span class="st">"I-GPE"</span>: <span class="st">"I-LOC"</span>,</span>
<span id="cb35-12"><a href="#cb35-12" tabindex="-1"></a>        <span class="st">"B-VEH"</span>: <span class="st">"O"</span>,</span>
<span id="cb35-13"><a href="#cb35-13" tabindex="-1"></a>        <span class="st">"I-VEH"</span>: <span class="st">"O"</span></span>
<span id="cb35-14"><a href="#cb35-14" tabindex="-1"></a>    }</span>
<span id="cb35-15"><a href="#cb35-15" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(filepath) <span class="im">as</span> f:</span>
<span id="cb35-16"><a href="#cb35-16" tabindex="-1"></a>        <span class="cf">for</span> line <span class="kw">in</span> f.readlines():</span>
<span id="cb35-17"><a href="#cb35-17" tabindex="-1"></a>            row <span class="op">=</span> line.strip().split(<span class="st">"</span><span class="ch">\t</span><span class="st">"</span>)</span>
<span id="cb35-18"><a href="#cb35-18" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(row) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb35-19"><a href="#cb35-19" tabindex="-1"></a>                sent_txt.append(row[<span class="dv">0</span>])</span>
<span id="cb35-20"><a href="#cb35-20" tabindex="-1"></a>                label <span class="op">=</span> row[gold_label_column]</span>
<span id="cb35-21"><a href="#cb35-21" tabindex="-1"></a>                <span class="cf">if</span> label <span class="kw">in</span> label_translator:</span>
<span id="cb35-22"><a href="#cb35-22" tabindex="-1"></a>                    final_label <span class="op">=</span> label_translator[label]</span>
<span id="cb35-23"><a href="#cb35-23" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb35-24"><a href="#cb35-24" tabindex="-1"></a>                    final_label <span class="op">=</span> label</span>
<span id="cb35-25"><a href="#cb35-25" tabindex="-1"></a>                sent_lbl.append(final_label)</span>
<span id="cb35-26"><a href="#cb35-26" tabindex="-1"></a>                <span class="cf">if</span> final_label <span class="kw">not</span> <span class="kw">in</span> label_vocab:</span>
<span id="cb35-27"><a href="#cb35-27" tabindex="-1"></a>                    label_vocab[final_label] <span class="op">=</span> <span class="bu">len</span>(label_vocab) </span>
<span id="cb35-28"><a href="#cb35-28" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb35-29"><a href="#cb35-29" tabindex="-1"></a>                all_sentences.append(<span class="st">" "</span>.join(sent_txt))</span>
<span id="cb35-30"><a href="#cb35-30" tabindex="-1"></a>                all_labels.append(sent_lbl)</span>
<span id="cb35-31"><a href="#cb35-31" tabindex="-1"></a>                sent_txt, sent_lbl <span class="op">=</span> [], []</span>
<span id="cb35-32"><a href="#cb35-32" tabindex="-1"></a>    <span class="cf">return</span> all_sentences, all_labels, label_vocab</span>
<span id="cb35-33"><a href="#cb35-33" tabindex="-1"></a></span>
<span id="cb35-34"><a href="#cb35-34" tabindex="-1"></a></span>
<span id="cb35-35"><a href="#cb35-35" tabindex="-1"></a>sentences, gold_labels, label_vocab <span class="op">=</span> quick_conll_reader(<span class="st">"1023_bleak_house_brat.tsv"</span>)</span>
<span id="cb35-36"><a href="#cb35-36" tabindex="-1"></a></span>
<span id="cb35-37"><a href="#cb35-37" tabindex="-1"></a><span class="bu">print</span>(sentences[<span class="dv">0</span>].split(<span class="st">' '</span>))</span>
<span id="cb35-38"><a href="#cb35-38" tabindex="-1"></a><span class="bu">print</span>(gold_labels[<span class="dv">0</span>])</span></code></pre>
</div>
<p>This code processes the <em>Bleak House</em> book and extracts a list
of tokenized sentences (as strings) and a list of IOB Labels
corresponding to each token in the sentence. You can see the first
sentence and its corresponding list of <em>gold labels</em> on this
example. Next, we load the NER pre-trained model again and process the
sentences to obtain model predictions. The problem here is that the
model predictions are lists of dictionaries and we need to post-process
them so they are also on IOB-format. We use the get_iob_labels()
function to do this conversion.</p>
<div class="codewrapper sourceCode" id="cb36">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a></span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a><span class="kw">def</span> token_to_spans(tokens):</span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a>    token2spans <span class="op">=</span> {}</span>
<span id="cb36-4"><a href="#cb36-4" tabindex="-1"></a>    char_start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb36-5"><a href="#cb36-5" tabindex="-1"></a>    <span class="cf">for</span> i, tok <span class="kw">in</span> <span class="bu">enumerate</span>(tokens):</span>
<span id="cb36-6"><a href="#cb36-6" tabindex="-1"></a>        tok_end <span class="op">=</span> char_start <span class="op">+</span> <span class="bu">len</span>(tok)</span>
<span id="cb36-7"><a href="#cb36-7" tabindex="-1"></a>        token2spans[i] <span class="op">=</span> (char_start, tok_end)</span>
<span id="cb36-8"><a href="#cb36-8" tabindex="-1"></a>        char_start <span class="op">=</span> tok_end <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb36-9"><a href="#cb36-9" tabindex="-1"></a>    <span class="cf">return</span> token2spans</span>
<span id="cb36-10"><a href="#cb36-10" tabindex="-1"></a></span>
<span id="cb36-11"><a href="#cb36-11" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" tabindex="-1"></a><span class="kw">def</span> get_litbank_labels(tokenized_sentence, entities):</span>
<span id="cb36-13"><a href="#cb36-13" tabindex="-1"></a>    <span class="co"># Initialize all labels empty</span></span>
<span id="cb36-14"><a href="#cb36-14" tabindex="-1"></a>    iob_labels <span class="op">=</span> [<span class="st">'O'</span>] <span class="op">*</span> <span class="bu">len</span>(tokenized_sentence)</span>
<span id="cb36-15"><a href="#cb36-15" tabindex="-1"></a>    <span class="co"># Get Token &lt;-&gt; Chars Mapping</span></span>
<span id="cb36-16"><a href="#cb36-16" tabindex="-1"></a>    tok2spans <span class="op">=</span> token_to_spans(tokenized_sentence)</span>
<span id="cb36-17"><a href="#cb36-17" tabindex="-1"></a>    start2tok <span class="op">=</span> {v[<span class="dv">0</span>]:k <span class="cf">for</span> k, v <span class="kw">in</span> tok2spans.items()}</span>
<span id="cb36-18"><a href="#cb36-18" tabindex="-1"></a>    end2tok <span class="op">=</span> {v[<span class="dv">1</span>]:k <span class="cf">for</span> k, v <span class="kw">in</span> tok2spans.items()}</span>
<span id="cb36-19"><a href="#cb36-19" tabindex="-1"></a>    <span class="co"># Iterate over each entity to populate labels</span></span>
<span id="cb36-20"><a href="#cb36-20" tabindex="-1"></a>    <span class="cf">for</span> entity <span class="kw">in</span> entities:</span>
<span id="cb36-21"><a href="#cb36-21" tabindex="-1"></a>        label <span class="op">=</span> entity[<span class="st">'entity_group'</span>]</span>
<span id="cb36-22"><a href="#cb36-22" tabindex="-1"></a>        <span class="cf">if</span> label <span class="op">==</span> <span class="st">"MISC"</span>:  <span class="co"># Design choice: Do NOT count MISC entities!</span></span>
<span id="cb36-23"><a href="#cb36-23" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb36-24"><a href="#cb36-24" tabindex="-1"></a>        token_start <span class="op">=</span> start2tok.get(entity[<span class="st">'start'</span>])</span>
<span id="cb36-25"><a href="#cb36-25" tabindex="-1"></a>        token_end <span class="op">=</span> end2tok.get(entity[<span class="st">'end'</span>])</span>
<span id="cb36-26"><a href="#cb36-26" tabindex="-1"></a>        </span>
<span id="cb36-27"><a href="#cb36-27" tabindex="-1"></a>        <span class="cf">if</span> token_start <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb36-28"><a href="#cb36-28" tabindex="-1"></a>            iob_labels[token_start] <span class="op">=</span> <span class="ss">f'B-</span><span class="sc">{</span>label<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb36-29"><a href="#cb36-29" tabindex="-1"></a>            <span class="cf">if</span> token_end <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb36-30"><a href="#cb36-30" tabindex="-1"></a>                <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(token_start<span class="op">+</span><span class="dv">1</span>, token_end<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb36-31"><a href="#cb36-31" tabindex="-1"></a>                    iob_labels[i] <span class="op">=</span> <span class="ss">f'I-</span><span class="sc">{</span>label<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb36-32"><a href="#cb36-32" tabindex="-1"></a>    </span>
<span id="cb36-33"><a href="#cb36-33" tabindex="-1"></a>    <span class="cf">return</span> iob_labels</span></code></pre>
</div>
<p>And we finally apply the model to the sentences that we previously
read:</p>
<div class="codewrapper sourceCode" id="cb37">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a></span>
<span id="cb37-2"><a href="#cb37-2" tabindex="-1"></a>ner_results <span class="op">=</span> ner_classifier(sentences)</span>
<span id="cb37-3"><a href="#cb37-3" tabindex="-1"></a>model_predictions <span class="op">=</span> []</span>
<span id="cb37-4"><a href="#cb37-4" tabindex="-1"></a><span class="cf">for</span> i, sentence_ner <span class="kw">in</span> <span class="bu">enumerate</span>(ner_results):</span>
<span id="cb37-5"><a href="#cb37-5" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">===== SENTENCE </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> ====="</span>)</span>
<span id="cb37-6"><a href="#cb37-6" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'Tokens:'</span>, sentences[i].split())</span>
<span id="cb37-7"><a href="#cb37-7" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'GOLD:'</span>, gold_labels[i])</span>
<span id="cb37-8"><a href="#cb37-8" tabindex="-1"></a>    <span class="co"># Get the IOB labels for the tokenized sentence</span></span>
<span id="cb37-9"><a href="#cb37-9" tabindex="-1"></a>    tokenized_sentence <span class="op">=</span> sentences[i].split()</span>
<span id="cb37-10"><a href="#cb37-10" tabindex="-1"></a>    predicted_iob_labels <span class="op">=</span> get_litbank_labels(tokenized_sentence, sentence_ner)</span>
<span id="cb37-11"><a href="#cb37-11" tabindex="-1"></a>    model_predictions.append(predicted_iob_labels)</span>
<span id="cb37-12"><a href="#cb37-12" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'MODEL:'</span>, predicted_iob_labels)</span>
<span id="cb37-13"><a href="#cb37-13" tabindex="-1"></a>    <span class="cf">for</span> nr <span class="kw">in</span> sentence_ner:</span>
<span id="cb37-14"><a href="#cb37-14" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f'</span><span class="ch">\t</span><span class="sc">{</span>nr<span class="sc">}</span><span class="ss">'</span>)</span></code></pre>
</div>
<p>For each model prediction we are printing the sentence tokens, the
IOB gold labels and the IOB predicitons. Now that the data is in this
shape we can perform evaluation.</p>
</div>
<div class="section level2">
<h2 id="model-evaluation">Model Evaluation<a class="anchor" aria-label="anchor" href="#model-evaluation"></a></h2>
<p>To perform evaluation in your data you can use again the
<code>seqeval</code> package:</p>
<div class="codewrapper sourceCode" id="cb38">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a></span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a><span class="im">from</span> seqeval.metrics <span class="im">import</span> classification_report</span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a><span class="bu">print</span>(classification_report(gold_labels, model_predictions))</span></code></pre>
</div>
<p>Since we took a classifier that was not trained for the book domain,
the performance is quite poor. But this example shows us that
classifiers performing very well on their own domain most of the times
transfer poorly to other apparently similar datasets.</p>
<p>The solution in this case is to use another of the great
characteristics of BERT: fine-tuning for domain adaptation. It is
possible to train your own classifier with relatively small data (given
that a lot of linguistic knowledge was already provided during the
language modeling pre-training). In the following section we will see
how to train your own NER model and use it for predictions.</p>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div>



      </div> <!-- / div.lesson-content -->
    </main><!-- / main#main-content.main-content --><nav class="bottom-pagination mx-md-4" aria-label="Previous and Next Chapter"><div class="d-block d-sm-block d-md-none">
        <a class="chapter-link" href="../instructor/01-preprocessing.html"><i aria-hidden="true" class="small-arrow" data-feather="arrow-left"></i>Previous</a>
        <a class="chapter-link float-end" href="../instructor/index.html">Next<i aria-hidden="true" class="small-arrow" data-feather="arrow-right"></i></a>
      </div>
      <!-- content for large screens -->
      <div class="d-none d-sm-none d-md-block">
        <a class="chapter-link" href="../instructor/01-preprocessing.html" rel="prev">
          <i aria-hidden="true" class="small-arrow" data-feather="arrow-left"></i>
          Previous: Episode 1: From text
        </a>
        <a class="chapter-link float-end" href="../instructor/index.html" rel="next">
          Home
          <i aria-hidden="true" class="small-arrow" data-feather="arrow-right"></i>
        </a>
      </div>
    </nav></div> <!-- / div.primary-content.col-xs-12 -->
<!-- END:   inst/pkgdown/templates/content-instructor.html-->

      </div><!--/div.row-->
      		<footer class="row footer mx-md-3"><hr><div class="col-md-6">
        <p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>

        <a href="https://github.com/esciencecenter-digital-skills/Natural-language-processing/edit/main/episodes/02-transformers.md" class="external-link">Edit on GitHub</a>

	
        | <a href="https://github.com/esciencecenter-digital-skills/Natural-language-processing/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a>
        | <a href="https://github.com/esciencecenter-digital-skills/Natural-language-processing/" class="external-link">Source</a></p>
				<p><a href="https://github.com/esciencecenter-digital-skills/Natural-language-processing/blob/main/CITATION.cff" class="external-link">Cite</a> | <a href="mailto:team@carpentries.org">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
			</div>
			<div class="col-md-6">

        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>

        <p>Template licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">CC-BY 4.0</a> by <a href="https://carpentries.org/" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper/tree/0.16.10" class="external-link">sandpaper (0.16.10)</a>, <a href="https://github.com/carpentries/pegboard/tree/0.7.7" class="external-link">pegboard (0.7.7)</a>, and <a href="https://github.com/carpentries/varnish/tree/1.0.5" class="external-link">varnish (1.0.5)</a></p>
			</div>
		</footer></div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
      <i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back To Top"></i><br><!-- <span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top --><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "TrainingMaterial",
  "@id": "https://esciencecenter-digital-skills.github.io/Natural-language-processing/instructor/02-transformers.html",
  "inLanguage": "en",
  "dct:conformsTo": "https://bioschemas.org/profiles/TrainingMaterial/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "software, data, lesson, The Carpentries, NLP, English, social sciences, pre-alpha",
  "name": "Episode 4: BERT and Transformers",
  "creativeWorkStatus": "active",
  "url": "https://esciencecenter-digital-skills.github.io/Natural-language-processing/instructor/02-transformers.html",
  "identifier": "https://esciencecenter-digital-skills.github.io/Natural-language-processing/instructor/02-transformers.html",
  "dateCreated": "2024-04-24",
  "dateModified": "2024-12-20",
  "datePublished": "2024-12-20"
}

  </script><script>
		feather.replace();
	</script></body></html><!-- END:   inst/pkgdown/templates/layout.html-->

